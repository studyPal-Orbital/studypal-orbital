{"ast":null,"code":"import { animated as t, to as n, useTransition as e, useSpring as r } from \"@react-spring/web\";\nimport { useTheme as i, radiansToDegrees as a, positionFromAngle as o, degreesToRadians as u, midAngle as l, useMotionConfig as s, usePropertyAccessor as d, textPropsByEngine as f, getDistance as c, getAngle as g } from \"@nivo/core\";\nimport { jsx as p, jsxs as h } from \"react/jsx-runtime\";\nimport { useMemo as v, createElement as A, useCallback as x } from \"react\";\nimport { useInheritedColor as R } from \"@nivo/colors\";\nimport { line as m, arc as y } from \"d3-shape\";\n\nfunction M() {\n  return M = Object.assign || function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var e = arguments[n];\n\n      for (var r in e) {\n        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n      }\n    }\n\n    return t;\n  }, M.apply(this, arguments);\n}\n\nvar k = {\n  pointerEvents: \"none\"\n},\n    C = function C(n) {\n  var e = n.label,\n      r = n.style,\n      a = i();\n  return p(t.g, {\n    transform: r.transform,\n    opacity: r.progress,\n    style: k,\n    children: p(t.text, {\n      textAnchor: \"middle\",\n      dominantBaseline: \"central\",\n      style: M({}, a.labels.text, {\n        fill: r.textColor\n      }),\n      children: e\n    })\n  });\n},\n    b = function b(t) {\n  var n = t % (2 * Math.PI);\n  return n < 0 && (n += 2 * Math.PI), n;\n},\n    L = function L(t, n) {\n  return t.filter(function (t) {\n    return Math.abs(a(t.arc.endAngle - t.arc.startAngle)) >= n;\n  });\n},\n    P = function P(t, n, e, r, i) {\n  return [\"A\", t, t, 0, n, e, r, i].join(\" \");\n},\n    O = [\"startAngle\", \"middleAngle\", \"endAngle\", \"innerRadius\", \"centerRadius\", \"outerRadius\", \"pushIn\", \"pushOut\"],\n    E = {\n  startAngle: {\n    enter: function enter(t) {\n      return M({}, t, {\n        endAngle: t.startAngle\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      return M({}, t, {\n        startAngle: t.endAngle\n      });\n    }\n  },\n  middleAngle: {\n    enter: function enter(t) {\n      var n = t.startAngle + (t.endAngle - t.startAngle) / 2;\n      return M({}, t, {\n        startAngle: n,\n        endAngle: n\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      var n = t.startAngle + (t.endAngle - t.startAngle) / 2;\n      return M({}, t, {\n        startAngle: n,\n        endAngle: n\n      });\n    }\n  },\n  endAngle: {\n    enter: function enter(t) {\n      return M({}, t, {\n        startAngle: t.endAngle\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      return M({}, t, {\n        endAngle: t.startAngle\n      });\n    }\n  },\n  innerRadius: {\n    enter: function enter(t) {\n      return M({}, t, {\n        outerRadius: t.innerRadius\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      return M({}, t, {\n        innerRadius: t.outerRadius\n      });\n    }\n  },\n  centerRadius: {\n    enter: function enter(t) {\n      var n = t.innerRadius + (t.outerRadius - t.innerRadius) / 2;\n      return M({}, t, {\n        innerRadius: n,\n        outerRadius: n\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      var n = t.innerRadius + (t.outerRadius - t.innerRadius) / 2;\n      return M({}, t, {\n        innerRadius: n,\n        outerRadius: n\n      });\n    }\n  },\n  outerRadius: {\n    enter: function enter(t) {\n      return M({}, t, {\n        innerRadius: t.outerRadius\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      return M({}, t, {\n        outerRadius: t.innerRadius\n      });\n    }\n  },\n  pushIn: {\n    enter: function enter(t) {\n      return M({}, t, {\n        innerRadius: t.innerRadius - t.outerRadius + t.innerRadius,\n        outerRadius: t.innerRadius\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      return M({}, t, {\n        innerRadius: t.outerRadius,\n        outerRadius: t.outerRadius + t.outerRadius - t.innerRadius\n      });\n    }\n  },\n  pushOut: {\n    enter: function enter(t) {\n      return M({}, t, {\n        innerRadius: t.outerRadius,\n        outerRadius: t.outerRadius + t.outerRadius - t.innerRadius\n      });\n    },\n    update: function update(t) {\n      return t;\n    },\n    leave: function leave(t) {\n      return M({}, t, {\n        innerRadius: t.innerRadius - t.outerRadius + t.innerRadius,\n        outerRadius: t.innerRadius\n      });\n    }\n  }\n},\n    I = function I(t, n) {\n  return v(function () {\n    var e = E[t];\n    return {\n      enter: function enter(t) {\n        return M({\n          progress: 0\n        }, e.enter(t.arc), n ? n.enter(t) : {});\n      },\n      update: function update(t) {\n        return M({\n          progress: 1\n        }, e.update(t.arc), n ? n.update(t) : {});\n      },\n      leave: function leave(t) {\n        return M({\n          progress: 0\n        }, e.leave(t.arc), n ? n.leave(t) : {});\n      }\n    };\n  }, [t, n]);\n},\n    T = function T(t, n) {\n  var e = l(t) - Math.PI / 2,\n      r = t.innerRadius + (t.outerRadius - t.innerRadius) * n;\n  return o(e, r);\n},\n    j = function j(t) {\n  return function (e, r, i, a) {\n    return n([e, r, i, a], function (n, e, r, i) {\n      var a = T({\n        startAngle: n,\n        endAngle: e,\n        innerRadius: r,\n        outerRadius: i\n      }, t);\n      return \"translate(\" + a.x + \",\" + a.y + \")\";\n    });\n  };\n},\n    W = function W(t, n, r, i) {\n  void 0 === n && (n = .5), void 0 === r && (r = \"innerRadius\");\n  var a = s(),\n      o = a.animate,\n      u = a.config,\n      l = I(r, i);\n  return {\n    transition: e(t, {\n      keys: function keys(t) {\n        return t.id;\n      },\n      initial: l.update,\n      from: l.enter,\n      enter: l.update,\n      update: l.update,\n      leave: l.leave,\n      config: u,\n      immediate: !o\n    }),\n    interpolate: j(n)\n  };\n},\n    S = function S(t) {\n  var n = t.data,\n      e = t.offset,\n      r = void 0 === e ? .5 : e,\n      i = t.skipAngle,\n      a = void 0 === i ? 0 : i,\n      o = t.computeExtraProps,\n      u = void 0 === o ? function () {\n    return {};\n  } : o;\n  return v(function () {\n    return L(n, a).map(function (t) {\n      var n = T(t.arc, r);\n      return M({}, u(t), {\n        x: n.x,\n        y: n.y,\n        data: t\n      });\n    });\n  }, [n, r, a, u]);\n},\n    B = function B(t) {\n  var n = t.center,\n      e = t.data,\n      r = t.transitionMode,\n      o = t.label,\n      u = t.radiusOffset,\n      l = t.skipAngle,\n      s = t.textColor,\n      f = t.component,\n      c = void 0 === f ? C : f,\n      g = d(o),\n      h = i(),\n      x = R(s, h),\n      m = v(function () {\n    return e.filter(function (t) {\n      return Math.abs(a(t.arc.endAngle - t.arc.startAngle)) >= l;\n    });\n  }, [e, l]),\n      y = W(m, u, r),\n      k = y.transition,\n      b = y.interpolate,\n      L = c;\n  return p(\"g\", {\n    transform: \"translate(\" + n[0] + \",\" + n[1] + \")\",\n    children: k(function (t, n) {\n      return A(L, {\n        key: n.id,\n        datum: n,\n        label: g(n),\n        style: M({}, t, {\n          transform: b(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius),\n          textColor: x(n)\n        })\n      });\n    })\n  });\n},\n    w = function w(t, n, e) {\n  t.textAlign = \"center\", t.textBaseline = \"middle\", t.font = e.labels.text.fontSize + \"px \" + e.labels.text.fontFamily, n.forEach(function (n) {\n    t.fillStyle = n.textColor, t.fillText(\"\" + n.label, n.x, n.y);\n  });\n},\n    z = function z(t) {\n  var n = t.data,\n      e = t.offset,\n      r = t.skipAngle,\n      a = t.label,\n      o = t.textColor,\n      u = d(a),\n      l = i(),\n      s = R(o, l),\n      f = x(function (t) {\n    return {\n      label: u(t),\n      textColor: s(t)\n    };\n  }, [u, s]);\n  return S({\n    data: n,\n    offset: e,\n    skipAngle: r,\n    computeExtraProps: f\n  });\n},\n    F = C,\n    G = function G(n) {\n  var e = n.label,\n      r = n.style,\n      a = i();\n  return h(t.g, {\n    opacity: r.opacity,\n    children: [p(t.path, {\n      fill: \"none\",\n      stroke: r.linkColor,\n      strokeWidth: r.thickness,\n      d: r.path\n    }), p(t.text, {\n      transform: r.textPosition,\n      textAnchor: r.textAnchor,\n      dominantBaseline: \"central\",\n      style: M({}, a.labels.text, {\n        fill: r.textColor\n      }),\n      children: e\n    })]\n  });\n},\n    q = function q(t) {\n  var n = b(t.startAngle + (t.endAngle - t.startAngle) / 2 - Math.PI / 2);\n  return n < Math.PI / 2 || n > 1.5 * Math.PI ? \"start\" : \"end\";\n},\n    D = function D(t, n, e, r) {\n  var i,\n      a,\n      u = b(t.startAngle + (t.endAngle - t.startAngle) / 2 - Math.PI / 2),\n      l = o(u, t.outerRadius + n),\n      s = o(u, t.outerRadius + n + e);\n  return u < Math.PI / 2 || u > 1.5 * Math.PI ? (i = \"after\", a = {\n    x: s.x + r,\n    y: s.y\n  }) : (i = \"before\", a = {\n    x: s.x - r,\n    y: s.y\n  }), {\n    side: i,\n    points: [l, s, a]\n  };\n},\n    H = m().x(function (t) {\n  return t.x;\n}).y(function (t) {\n  return t.y;\n}),\n    J = function J(t, e, r, i, a, o, u) {\n  return n([t, e, r, i, a, o, u], function (t, n, e, r, i, a, o) {\n    var u = D({\n      startAngle: t,\n      endAngle: n,\n      innerRadius: e,\n      outerRadius: r\n    }, i, a, o).points;\n    return H(u);\n  });\n},\n    K = function K(t, e, r, i) {\n  return n([t, e, r, i], function (t, n, e, r) {\n    return q({\n      startAngle: t,\n      endAngle: n,\n      innerRadius: e,\n      outerRadius: r\n    });\n  });\n},\n    N = function N(t, e, r, i, a, o, u, l) {\n  return n([t, e, r, i, a, o, u, l], function (t, n, e, r, i, a, o, u) {\n    var l = D({\n      startAngle: t,\n      endAngle: n,\n      innerRadius: e,\n      outerRadius: r\n    }, i, a, o),\n        s = l.points,\n        d = l.side,\n        f = s[2];\n    return \"before\" === d ? f.x -= u : f.x += u, \"translate(\" + f.x + \",\" + f.y + \")\";\n  });\n},\n    Q = function Q(t) {\n  var n = t.data,\n      r = t.offset,\n      a = void 0 === r ? 0 : r,\n      o = t.diagonalLength,\n      u = t.straightLength,\n      l = t.skipAngle,\n      d = void 0 === l ? 0 : l,\n      f = t.textOffset,\n      c = t.linkColor,\n      g = t.textColor,\n      p = s(),\n      h = p.animate,\n      A = p.config,\n      x = i(),\n      m = R(c, x),\n      y = R(g, x),\n      M = function (t, n) {\n    return v(function () {\n      return L(t, n);\n    }, [t, n]);\n  }(n, d),\n      k = function (t) {\n    var n = t.offset,\n        e = t.diagonalLength,\n        r = t.straightLength,\n        i = t.textOffset,\n        a = t.getLinkColor,\n        o = t.getTextColor;\n    return v(function () {\n      return {\n        enter: function enter(t) {\n          return {\n            startAngle: t.arc.startAngle,\n            endAngle: t.arc.endAngle,\n            innerRadius: t.arc.innerRadius,\n            outerRadius: t.arc.outerRadius,\n            offset: n,\n            diagonalLength: 0,\n            straightLength: 0,\n            textOffset: i,\n            linkColor: a(t),\n            textColor: o(t),\n            opacity: 0\n          };\n        },\n        update: function update(t) {\n          return {\n            startAngle: t.arc.startAngle,\n            endAngle: t.arc.endAngle,\n            innerRadius: t.arc.innerRadius,\n            outerRadius: t.arc.outerRadius,\n            offset: n,\n            diagonalLength: e,\n            straightLength: r,\n            textOffset: i,\n            linkColor: a(t),\n            textColor: o(t),\n            opacity: 1\n          };\n        },\n        leave: function leave(t) {\n          return {\n            startAngle: t.arc.startAngle,\n            endAngle: t.arc.endAngle,\n            innerRadius: t.arc.innerRadius,\n            outerRadius: t.arc.outerRadius,\n            offset: n,\n            diagonalLength: 0,\n            straightLength: 0,\n            textOffset: i,\n            linkColor: a(t),\n            textColor: o(t),\n            opacity: 0\n          };\n        }\n      };\n    }, [e, r, i, a, o]);\n  }({\n    offset: a,\n    diagonalLength: o,\n    straightLength: u,\n    textOffset: f,\n    getLinkColor: m,\n    getTextColor: y\n  });\n\n  return {\n    transition: e(M, {\n      keys: function keys(t) {\n        return t.id;\n      },\n      initial: k.update,\n      from: k.enter,\n      enter: k.update,\n      update: k.update,\n      leave: k.leave,\n      config: A,\n      immediate: !h\n    }),\n    interpolateLink: J,\n    interpolateTextAnchor: K,\n    interpolateTextPosition: N\n  };\n},\n    U = function U(t) {\n  var n = t.center,\n      e = t.data,\n      r = t.label,\n      i = t.skipAngle,\n      a = t.offset,\n      o = t.diagonalLength,\n      u = t.straightLength,\n      l = t.strokeWidth,\n      s = t.textOffset,\n      f = t.textColor,\n      c = t.linkColor,\n      g = t.component,\n      h = void 0 === g ? G : g,\n      v = d(r),\n      x = Q({\n    data: e,\n    skipAngle: i,\n    offset: a,\n    diagonalLength: o,\n    straightLength: u,\n    textOffset: s,\n    linkColor: c,\n    textColor: f\n  }),\n      R = x.transition,\n      m = x.interpolateLink,\n      y = x.interpolateTextAnchor,\n      k = x.interpolateTextPosition,\n      C = h;\n  return p(\"g\", {\n    transform: \"translate(\" + n[0] + \",\" + n[1] + \")\",\n    children: R(function (t, n) {\n      return A(C, {\n        key: n.id,\n        datum: n,\n        label: v(n),\n        style: M({}, t, {\n          thickness: l,\n          path: m(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius, t.offset, t.diagonalLength, t.straightLength),\n          textAnchor: y(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius),\n          textPosition: k(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius, t.offset, t.diagonalLength, t.straightLength, t.textOffset)\n        })\n      });\n    })\n  });\n},\n    V = function V(t, n, e, r) {\n  t.textBaseline = \"middle\", t.font = e.labels.text.fontSize + \"px \" + e.labels.text.fontFamily, n.forEach(function (n) {\n    t.fillStyle = n.textColor, t.textAlign = f.canvas.align[n.textAnchor], t.fillText(\"\" + n.label, n.x, n.y), t.beginPath(), t.strokeStyle = n.linkColor, t.lineWidth = r, n.points.forEach(function (n, e) {\n      0 === e ? t.moveTo(n.x, n.y) : t.lineTo(n.x, n.y);\n    }), t.stroke();\n  });\n},\n    X = function X(t) {\n  var n = t.data,\n      e = t.skipAngle,\n      r = void 0 === e ? 0 : e,\n      i = t.offset,\n      o = void 0 === i ? .5 : i,\n      u = t.diagonalLength,\n      l = t.straightLength,\n      s = t.computeExtraProps,\n      d = void 0 === s ? function () {\n    return {};\n  } : s,\n      f = v(function () {\n    return n.filter(function (t) {\n      return Math.abs(a(t.arc.endAngle - t.arc.startAngle)) >= r;\n    }).map(function (t) {\n      return M({}, D(t.arc, o, u, l), {\n        data: t\n      });\n    });\n  }, [n, r, o, u, l]);\n  return v(function () {\n    return f.map(function (t) {\n      return M({}, d(t), t);\n    });\n  }, [f, d]);\n},\n    Y = function Y(t) {\n  var n = t.data,\n      e = t.skipAngle,\n      r = t.offset,\n      a = t.diagonalLength,\n      o = t.straightLength,\n      u = t.textOffset,\n      l = void 0 === u ? 0 : u,\n      s = t.label,\n      f = t.linkColor,\n      c = t.textColor,\n      g = d(s),\n      p = i(),\n      h = R(f, p),\n      v = R(c, p),\n      A = x(function (t) {\n    var n,\n        e = {\n      x: t.points[2].x,\n      y: t.points[2].y\n    };\n    return \"before\" === t.side ? (e.x -= l, n = \"end\") : (e.x += l, n = \"start\"), M({}, e, {\n      label: g(t.data),\n      linkColor: h(t.data),\n      textAnchor: n,\n      textColor: v(t.data)\n    });\n  }, [g, h, v, l]);\n  return X({\n    data: n,\n    skipAngle: e,\n    offset: r,\n    diagonalLength: a,\n    straightLength: o,\n    computeExtraProps: A\n  });\n},\n    Z = G,\n    $ = [\"animated\"],\n    _ = function _(e) {\n  var r = e.animated,\n      i = function (t, n) {\n    if (null == t) return {};\n    var e,\n        r,\n        i = {},\n        a = Object.keys(t);\n\n    for (r = 0; r < a.length; r++) {\n      e = a[r], n.indexOf(e) >= 0 || (i[e] = t[e]);\n    }\n\n    return i;\n  }(e, $);\n\n  return p(t.path, M({\n    d: n([r.radius, r.startAngle, r.endAngle], function (t, n, e) {\n      return function (t, n, e) {\n        var r = Math.min(n, e),\n            i = Math.max(n, e),\n            a = o(u(i), t),\n            l = o(u(r), t);\n\n        if (i - r >= 360) {\n          var s = o(u(r + 180), t);\n          return [\"M \" + a.x + \" \" + a.y, P(t, 1, 1, s.x, s.y), \"M \" + a.x + \" \" + a.y, P(t, 1, 0, s.x, s.y)].join(\" \");\n        }\n\n        var d = i - r <= 180 ? 0 : 1;\n        return [\"M \" + a.x + \" \" + a.y, P(t, d, 0, l.x, l.y)].join(\" \");\n      }(t, n, e);\n    })\n  }, i));\n},\n    tt = function tt(n) {\n  var e = n.datum,\n      r = n.style,\n      i = n.onClick,\n      a = n.onMouseEnter,\n      o = n.onMouseMove,\n      u = n.onMouseLeave,\n      l = x(function (t) {\n    return null == i ? void 0 : i(e, t);\n  }, [i, e]),\n      s = x(function (t) {\n    return null == a ? void 0 : a(e, t);\n  }, [a, e]),\n      d = x(function (t) {\n    return null == o ? void 0 : o(e, t);\n  }, [o, e]),\n      f = x(function (t) {\n    return null == u ? void 0 : u(e, t);\n  }, [u, e]);\n  return p(t.path, {\n    d: r.path,\n    opacity: r.opacity,\n    fill: e.fill || r.color,\n    stroke: r.borderColor,\n    strokeWidth: r.borderWidth,\n    onClick: i ? l : void 0,\n    onMouseEnter: a ? s : void 0,\n    onMouseMove: o ? d : void 0,\n    onMouseLeave: u ? f : void 0\n  });\n},\n    nt = function nt(t, e, r, i, a) {\n  return n([t, e, r, i], function (t, n, e, r) {\n    return a({\n      startAngle: t,\n      endAngle: n,\n      innerRadius: Math.max(0, e),\n      outerRadius: Math.max(0, r)\n    });\n  });\n},\n    et = function et(t, n, r) {\n  void 0 === n && (n = \"innerRadius\");\n  var i = s(),\n      a = i.animate,\n      o = i.config,\n      u = I(n, r);\n  return {\n    transition: e(t, {\n      keys: function keys(t) {\n        return t.id;\n      },\n      initial: u.update,\n      from: u.enter,\n      enter: u.update,\n      update: u.update,\n      leave: u.leave,\n      config: o,\n      immediate: !a\n    }),\n    interpolate: nt\n  };\n},\n    rt = function rt(t) {\n  var n = t.center,\n      e = t.data,\n      r = t.arcGenerator,\n      a = t.borderWidth,\n      o = t.borderColor,\n      u = t.onClick,\n      l = t.onMouseEnter,\n      s = t.onMouseMove,\n      d = t.onMouseLeave,\n      f = t.transitionMode,\n      c = t.component,\n      g = void 0 === c ? tt : c,\n      h = i(),\n      v = R(o, h),\n      x = et(e, f, {\n    enter: function enter(t) {\n      return {\n        opacity: 0,\n        color: t.color,\n        borderColor: v(t)\n      };\n    },\n    update: function update(t) {\n      return {\n        opacity: 1,\n        color: t.color,\n        borderColor: v(t)\n      };\n    },\n    leave: function leave(t) {\n      return {\n        opacity: 0,\n        color: t.color,\n        borderColor: v(t)\n      };\n    }\n  }),\n      m = x.transition,\n      y = x.interpolate,\n      k = g;\n  return p(\"g\", {\n    transform: \"translate(\" + n[0] + \",\" + n[1] + \")\",\n    children: m(function (t, n) {\n      return A(k, {\n        key: n.id,\n        datum: n,\n        style: M({}, t, {\n          borderWidth: a,\n          path: y(t.startAngle, t.endAngle, t.innerRadius, t.outerRadius, r)\n        }),\n        onClick: u,\n        onMouseEnter: l,\n        onMouseMove: s,\n        onMouseLeave: d\n      });\n    })\n  });\n},\n    it = function it(t, n, e, r, i, a) {\n  void 0 === a && (a = !0);\n  var l = [],\n      s = o(u(r), e);\n  l.push([s.x, s.y]);\n  var d = o(u(i), e);\n  l.push([d.x, d.y]);\n\n  for (var f = Math.round(Math.min(r, i)); f <= Math.round(Math.max(r, i)); f++) {\n    if (f % 90 == 0) {\n      var c = o(u(f), e);\n      l.push([c.x, c.y]);\n    }\n  }\n\n  l = l.map(function (e) {\n    var r = e[0],\n        i = e[1];\n    return [t + r, n + i];\n  }), a && l.push([t, n]);\n  var g = l.map(function (t) {\n    return t[0];\n  }),\n      p = l.map(function (t) {\n    return t[1];\n  }),\n      h = Math.min.apply(Math, g),\n      v = Math.max.apply(Math, g),\n      A = Math.min.apply(Math, p);\n  return {\n    points: l,\n    x: h,\n    y: A,\n    width: v - h,\n    height: Math.max.apply(Math, p) - A\n  };\n},\n    at = function at(t, n, e, r, i, a) {\n  var o = c(i, a, t, n);\n  return o < e && o > r;\n},\n    ot = function ot(t, n, e, r, i, a, o) {\n  if (at(t, n, e, r, a, o)) {\n    var u = g(a, o, t, n);\n    return i.find(function (t) {\n      var n = t.startAngle,\n          e = t.endAngle;\n      return u >= n && u < e;\n    });\n  }\n},\n    ut = function ut(t, n) {\n  var e = s(),\n      i = e.animate,\n      a = e.config,\n      o = r({\n    startAngle: t.arc.startAngle,\n    endAngle: t.arc.endAngle,\n    innerRadius: t.arc.innerRadius,\n    outerRadius: t.arc.outerRadius,\n    config: a,\n    immediate: !i\n  });\n  return M({}, o, {\n    path: nt(o.startAngle, o.endAngle, o.innerRadius, o.outerRadius, n)\n  });\n},\n    lt = function lt(t) {\n  var n = void 0 === t ? {} : t,\n      e = n.cornerRadius,\n      r = void 0 === e ? 0 : e,\n      i = n.padAngle,\n      a = void 0 === i ? 0 : i;\n  return v(function () {\n    return y().innerRadius(function (t) {\n      return t.innerRadius;\n    }).outerRadius(function (t) {\n      return t.outerRadius;\n    }).cornerRadius(r).padAngle(a);\n  }, [r, a]);\n};\n\nexport { F as ArcLabelComponent, B as ArcLabelsLayer, _ as ArcLine, Z as ArcLinkLabelComponent, U as ArcLinkLabelsLayer, tt as ArcShape, rt as ArcsLayer, E as arcTransitionModeById, O as arcTransitionModes, it as computeArcBoundingBox, T as computeArcCenter, D as computeArcLink, q as computeArcLinkTextAnchor, w as drawCanvasArcLabels, V as drawCanvasArcLinkLabels, ot as findArcUnderCursor, nt as interpolateArc, j as interpolateArcCenter, at as isCursorInRing, ut as useAnimatedArc, S as useArcCenters, W as useArcCentersTransition, lt as useArcGenerator, z as useArcLabels, Y as useArcLinkLabels, Q as useArcLinkLabelsTransition, X as useArcLinks, I as useArcTransitionMode, et as useArcsTransition };","map":null,"metadata":{},"sourceType":"module"}